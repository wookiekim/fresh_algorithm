# [Greedy Algorithm](http://ivis.kr/images/4/46/4%EC%9E%A5%EA%B7%B8%EB%A6%AC%EB%94%94%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.pdf)

최적해를 구할 때 사용되는 근사적인 방법이다. 단계마다 그 순간에 최적으로 생각되는 것을 선택하여 최종적인 해답에 도달하는 방법이다. 같은 문제에 대해서 동적 프로그래밍(Dynamic Programming)보다 정확성은 조금 떨어져도 빠르게 결과에 도출할 수 있다.~~정확한 차이는 잘 모른다. 앞으로 더 공부해나가는걸로ㅎㅎ~~  
같은말: 탐욕 알고리즘, 욕심쟁이 알고리즘


## 어떻게 사용해야 하나요?

대표 예제인 거스름돈 문제를 통해 그리디 알고리즘을 자세히 살펴보자.
> 1260원만큼의 거스름돈을 거슬러주어야 할 때, 가장 적은 수의 동전을 사용하여 거슬러 주는 경우는? 동전의 종류는 500원, 100원, 50원, 10원이다.

<br>

그리디 알고리즘은 미리 정한 기준에 따라서 각 단계마다 그 순간에 최대 또는 최소값을  **근시안적**으로 선택한다. 
> 거스름돈 문제에서 미리 정한 기준은 _'남은 액수를 초과하지 않는 범위에서 가장 큰 액면의 동전을 취하는 것 '_ 이다. ~~가능한 가장 큰 액면의 동전을 최대로 취하는 것이 더 좋다고 생각했지만 다들 한 번에 포함시키지 않고 한번에 하나씩만 해를 선택해 나간다~~

<br>

각 단계에서 수행하는 작업은 세 가지이다. 
1. __해 선택 (Selection Procedure)__ : 해당 단계에서 가장 최적인 해를 구하여, 부분해 집합에 포함한다.
> 현재 고를 수 있는 가장 큰 액면의 동전은 500원이다. 그러므로 500원을 부분해 집합에 포함시킨다. (이 경우에는 동전의 개수를 제한하지 않았으니 무조건 500원을 포함하게 된다.)
> 현재 거스름돈: (500, )

2. __적절성 검사 (Feasibility Check)__ : 1의 결과로 나온 부분해 집합이 해에 포함될 수 있는지 확인한다. 포함될 수 없다면 1로 다시 돌아가 한 단계 낮거나 높은 선택지로 다시 고른다.
> 500은 1260원을 초과하지 않음으로 적절하다.

3. __해 검사 (Solution Check)__ : 지금까지 구해진 부분해 집합이 문제에서 요구하는 해가 될 수 있는지 확인한다. 해가 완성되지 못했다면 1로 다시 돌아가 동일한 작업을 수행한다.
> 500 != 1260 이므로 1, 2의 과정을 다시 반복한다.

위 단계를 반복하다 보면 해에 도달할 수 있다.
>  (500, ) -> (500, 500) -> (500, 500, 500, ) _1260원 초과_ <br>
>  -> (500, 500, 100, ) -> (500, 500, 100, 100, ) -> (500, 500, 100, 100, 100) _1260원 초과_ <br>
>  -> (500, 500, 100, 100, 50) -> (500, 500, 100, 100, 50, 50) _1260원 초과_ <br>
>  -> (500, 500, 100, 100, 50, 10) _정답!!_

위의 과정을 코드로 나타내면 아래와 같다.
```
int main()
{
	int n; // 거스름돈 액수
        int coin[5]={500,100,50,10,1}; //사용되는 동전
        int num = 0; // 동전의 개수
        
        cin >> n ;

	for(int i=0;i<5;i++){ // 사용되는 동전의 종류 만큼 반복, 내림차순으로
		while(n>=coin[i]){ // 남은 금액을 넘지 않는 범위까지 
			n -= coin[i]; // 해당 동전을 추가한다
			num++;
		}
	}
	
	cout << num;
}
```

눈치가 빠른 사람은 눈치 챘겠지만 그리디 알고리즘 단계는 기본적으로 무조건 큰 순서대로 또는 무조건 작은 순서대로 진행한다. 
> 500원짜리 동전부터 시작해서 100원, 50원, 10원 순으로 해에 포함시킨다.

<br>


## 언제 사용해야 하나요?

그리디 알고리즘은 계산량 측면에서 매우 실용적인 알고리즘이다. 하지만 순간적으로 선택한 최적의 값이 모여서 최적해가 되리라는 것을 보장하지 못한다. local optimum에 갖힐 수 있기 때문이다. 마시멜로 문제에서 그리디 알고리즘을 사용한다면 결과는 최악일 것이다ㅠㅠ

다음 2가지의 조건이 성립할 때 그리디 알고리즘을 활용해 볼 수 있다.

### 1. 탐욕스런 선택 조건 (Greedy Choice Property)
*  이전의 선택이 이후의 선택에 영향을 주지 않는다는 것을 의미한다. 
* The choice made by a greedy algorithm may depend on choices made so far, but not on future choices or all the solutions to the subproblem. It iteratively makes one greedy choice after another, reducing each given problem into a smaller one. In other words, a _greedy algorithm never reconsiders its choices._ <- 동적 계획법과 가장 큰 차이점
	
	
### 2. [최적 부분 구조 조건 (Optimal Substructure)](https://en.wikipedia.org/wiki/Optimal_substructure)
* 최적해의 구조와 관련된 이야기이다. 최적해가 부분 문제의 최적해를 포함하고 있을 때, 최적 부분 구조를 가졌다고 말한다. ~~무슨말인지 모르겠다ㅎㅎ~~ 
* 'A problem is said to have **optimal substructure** if an optimal solution can be constructed from optimal solutions of its subproblems.'라고 한다. 즉 전체 문제의 최적해가 부분 문제의 최적해들로 구성된는 경우이다.

하지만 위의 조건을 만족하지 않더라도 근사 알고리즘으로 사용할 수 있다. 다만 이 경우 어느 정도까지 최적해에 가까운 해를 구해낼 수 있는지는 증명을 통해 알아내어야 한다.


## 어떤 문제들이 있나요?
### 1. [MST, Minimum Spanning tree, 최소 신장 트리](https://www.zerocho.com/category/Algorithm/post/584bcd42580277001862f1a7)
 * Kruskal Algorithm : 사이클이 생기지 않도록 한 가장 짧은 엣지부터 선택한다.
 * Prim Algorithm : 선택된 노드 집합에서 선택되지 않은 노드들 중에 가장 가까운 노드부터 선택한다.

### 2. Shortest Path, 최단 경로 찾기
* [Dijkstra algorithm, 다익스트라 알고리즘](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%81%AC%EC%8A%A4%ED%8A%B8%EB%9D%BC_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98) : 소스 노드에서 가장 가까운 방문하지 않은 꼭짓점을 선택하고, 방문하지 않은 각 인접 노드와의 거리를 계산한 최솟값을 해당 노드까지의 거리로 설정한다. 모든 노드를 방문할 때까지 반복한다.

### 3. Fractional Knapsack Problem, 부분 배낭 문제
* 배낭이 한정된 무게의 물 건들을 담을 수 있을 때, 최대의 가치를 갖도록 배낭에 넣 을 물건들을 정하는 문제
* 거스름돈 문제와 비슷한 방법으로 푼다. 단위 무게당 가장 값나가는 물건을 가능한 개수만큼 배낭에 넣고, 계속해서 그 다음으로 값나가는 물건을 넣는다. 만약 짐을 쪼개지 못하는 경우(개수를 지정할 수 없을 때)는 0-1 Knapsack Problem로 동적 계획법으로 풀어야한다.

### 4. Set Cover, 집합 커버 문제
* 어떠한 전체집합과 그 집합의 부분집합들이 주어졌을 때, 부분집합들 중에서 가능한 한 적은 집합을 골라서 그 집합들의 합집합이 전체집합이 되는 부분집합의 집합을 구하는 문제
* 가능한 모든 부분 집합을 구한 다음, 최대한 많이 커버하는 순으로 집합을 선택한다.

### 5. Task Scheduling, 작업 스케줄링
* 작업의 수행 시간이 중복되지 않도록 모든 작업을 가장 적은 수의 기계에 배정하는 문제
*  빠른 시작시간 우선 배정(Earliest start time first), 빠른 종료시간 우선 배정(Earliest finish time first), 짧은 작업 우선 배정(Shortest job first), 긴 작업 우선 배정(Longest job first)가 있다. 빠른 시작시간 우선 배정을 제외하고는 항상 최적해를 보장하지 못한다.  
* 비슷한 문제로 한정된 기계의 수에 가능한 많은 작업을 배치하는 문제도 있다.
